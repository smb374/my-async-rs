# Future trait mechanism

The `Future` trait is defined as:

```rust
pub trait Future {
    type Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

The trait defines:
1. `Output`: The execution result of the underlying `Future`.
2. `poll`: The method that triggers the execution of a `Future` object. Returns `Poll` with two states:
    - `Poll::Ready(Output)`: The `Future` successfully executes with its return value.
    - `Poll::Pending`: The `Future` is currently pending, check it later to get the execution result.

By design, a `Future` object is lazy unless someone triggers the `poll` method defined
by the trait. The `poll` method contains a few unusual structs in it, including:
1. `Pin`
2. `Context`

We will look into these two struct in the following sections.

## 1. The `Pin<P>` smart pointer
The `Pin<P>` smart pointer is a wrapper around the `P` pointer that ensures the pointee
will not move out of it's current address, i.e. the address that `P` points to. This effect is
canceled if the pointee type implements the `Unpin` auto trait.

For example, the `std::mem::swap` can swap the pointee of two pointers, which essentially "moves"
the pointee out of its original place. If we wrap the two pointers with `Pin`, the use of `swap`
is forbidden, the code will failed to compile.

The reason of the use of `Pin` is mostly for the self referral structures.
Consider the following structure:
```rust
struct SelfRef {
    buf: [u8; 4096],
    p: &[u8],
}
```
If the field `p` points to the field `buf`, when the whole struct is moved, the underlying fields will also be moved
while the pointer `p` is still pointing the location of `buf` before the move occurs. We can clearly see that
the following access `p` will cause undefined behavior since the pointee may be a different type or `p` becomes
a dangling pointer. With the use of `Pin`, we can avoid this kind of stuff and prevent undefined behavior.
These kind of type will also implements `!Unpin` to make `Pin` has its effect on the type.

The reason that `poll` requires this bound is related to the next section. For now, we will discuss `Unpin` and `Context` first.

### The `Unpin` auto trait
The type with `Unpin` auto trait implemented will cancel the effect of `Pin`, e.g. `Pin<Box<T>>` is as same as `Box<T>` when `T: Unpin`.
The reason is that these types doesn't depend on its location to work properly. The only exception is those types who implements `!Unpin`.

There are only 4 kinds of types that implements `!Unpin`:
1. `Future` generated by the compiler with the `async fn` syntax.
2. `PhantomPinned` marker type.
3. Structs that contains `!Unpin` type in its field.
4. `unsafe impl !Unpin for [what ever type here]`

The reason of why the compiler generated `Future` will be discussed in the next section. Now let's focus on `Context` first.

## 2. `Context<'a>`
This type defines the context of a async task. It's currently used to provide the access to a reference of a `Waker` that can wake
up the current task.

A `Waker` is essentially a wrapper to a vtable (`RawWakerVTable`) and some extra payloads (`data` pointer). The vtable contains:
1. `clone`: Function to run when the waker is cloned.
2. `wake`: Function to run when `Waker::wake` is called. It will consume the `data` pointer.
3. `wake_by_ref`: Function to run when `Waker::wake_by_ref` is called. It won't consume the `data` pointer.
4. `drop`: Function to run when the `Waker` is dropped.

Typically, the creation of a `Waker` is done by some other libraries (e.g. `waker_fn` for my implementation).
The `Waker`s' management will be discussed in [Waker handling](../fth/waker_handling.md)
