# General commands of a runtime

Imagine you're a user that holds a pool of `Future` objects that is ready to execute, and the `Executor`
as a server that is capable to execute your `Future` objects with their results return to you.

Naturally, you'll want to send a request that asks the server to execute your task. You can, of course, choose
to wait until the server finishes the task and retrieves its result, or you can choose to tell the server: Give
me a handle, and I'll check its status later. Let's call the latter one `spawn`.

We can show the differences with the following snippet:

```rust
// Wait until `f()` finishes and retrieve its result.
async fn af1() {
    let result = f().await;
    // Do the rest of stuff...
}
async fn af2() {
    let handle = spawn(f());
    // Do other stuff...
    // Check the result of execution.
    let result = handle.join().await;
}
```

As you can see, we need to define a `spawn` function to handle these kinds of requests.
Note that in the first case, no extra `Future` object is created as it will become a state of the `Future`
object generated by `af1()`'s code, so we don't need a command to handle it.

Now, let's say that you're done with the works, and you want to shut down the server. Naturally,
you'll call the `shutdown` command to close the server before exit.

By the above situation, we can see that we need two essential commands: `spawn()` and `shutdown()` to control
the `Executor` we need to use. Of course there can be more commands, but for `my-async`, these commands are enough.
Now, let's talk about how we can design the `Executor` we need with the requirements.
