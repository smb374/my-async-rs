<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Design and Implementation Detail of my-async</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Prerequisite Knowledges</li><li class="chapter-item expanded "><a href="pre/async_in_rust.html"><strong aria-hidden="true">1.</strong> Async in Rust</a></li><li class="chapter-item expanded "><a href="pre/overview.html"><strong aria-hidden="true">2.</strong> Overview of an executor's architechture</a></li><li class="chapter-item expanded "><a href="pre/single_thread_executor.html"><strong aria-hidden="true">3.</strong> A minimal single-threded Future evaluator</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pre/single_future_handle.html"><strong aria-hidden="true">3.1.</strong> Future handling</a></li><li class="chapter-item expanded "><a href="pre/single_global_storage.html"><strong aria-hidden="true">3.2.</strong> Global Storages</a></li><li class="chapter-item expanded "><a href="pre/single_message_passing.html"><strong aria-hidden="true">3.3.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="pre/single_executor.html"><strong aria-hidden="true">3.4.</strong> Executor Main Loop</a></li><li class="chapter-item expanded "><a href="pre/single_final_code.html"><strong aria-hidden="true">3.5.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">First layer - Future and IoWrapper</li><li class="chapter-item expanded "><a href="layer/fst/future_trait.html"><strong aria-hidden="true">4.</strong> Bone of async - Future trait</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer/fst/future_in_depth.html"><strong aria-hidden="true">4.1.</strong> Future in depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer/fst/fsm.html"><strong aria-hidden="true">4.1.1.</strong> Future desugar - a Finite State Machine</a></li><li class="chapter-item expanded "><a href="layer/fst/mechanism.html"><strong aria-hidden="true">4.1.2.</strong> Future trait mechanism</a></li><li class="chapter-item expanded "><a href="layer/fst/challenge.html"><strong aria-hidden="true">4.1.3.</strong> The challenge of implementing an executor</a></li></ol></li><li class="chapter-item expanded "><a href="layer/fst/handling.html"><strong aria-hidden="true">4.2.</strong> Generic Future handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer/fst/heap_alloc.html"><strong aria-hidden="true">4.2.1.</strong> General heap-allocated Future object</a></li><li class="chapter-item expanded "><a href="layer/fst/pool.html"><strong aria-hidden="true">4.2.2.</strong> Global Reusable Object Pool for fragment controll and Future managment</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="layer/fst/io_wrapper.html"><strong aria-hidden="true">5.</strong> IO Adapter for general file descriptor - IoWrapper</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer/fst/io_handling.html"><strong aria-hidden="true">5.1.</strong> General IO handling</a></li><li class="chapter-item expanded "><a href="layer/fst/io_wrapper_design.html"><strong aria-hidden="true">5.2.</strong> IoWrapper design</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Second layer - Executor and message passing</li><li class="chapter-item expanded "><a href="layer/snd/executor.html"><strong aria-hidden="true">6.</strong> Heart of a runtime - Executor</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer/snd/commands.html"><strong aria-hidden="true">6.1.</strong> General commands of a runtime</a></li><li class="chapter-item expanded "><a href="layer/snd/message_handling.html"><strong aria-hidden="true">6.2.</strong> Design of Executor - an abstraction to scheduler and reactor</a></li></ol></li><li class="chapter-item expanded "><a href="layer/snd/message_passing.html"><strong aria-hidden="true">7.</strong> Passing messages</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer/snd/spawner.html"><strong aria-hidden="true">7.1.</strong> Spawner - message sender</a></li><li class="chapter-item expanded "><a href="layer/snd/message_payload.html"><strong aria-hidden="true">7.2.</strong> Message payload</a></li></ol></li><li class="chapter-item expanded "><a href="layer/snd/join_handle.html"><strong aria-hidden="true">8.</strong> Join Handle for Future</a></li><li class="chapter-item expanded affix "><li class="part-title">Third layer - Scheduler and schedule problems</li><li class="chapter-item expanded "><a href="layer/trd/scheduler.html"><strong aria-hidden="true">9.</strong> Multithread mania - Scheduler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer/trd/scheduler_trait.html"><strong aria-hidden="true">9.1.</strong> Scheduler trait design</a></li><li class="chapter-item expanded "><a href="layer/trd/worker_structure.html"><strong aria-hidden="true">9.2.</strong> General Worker structure and logic</a></li></ol></li><li class="chapter-item expanded "><a href="layer/trd/threading_method.html"><strong aria-hidden="true">10.</strong> Threading Method</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer/trd/round_robin.html"><strong aria-hidden="true">10.1.</strong> Round Robin</a></li><li class="chapter-item expanded "><a href="layer/trd/work_stealing.html"><strong aria-hidden="true">10.2.</strong> Work Stealing</a></li><li class="chapter-item expanded "><a href="layer/trd/hybrid.html"><strong aria-hidden="true">10.3.</strong> Hybrid Queue for Prioritized Work Stealing</a></li></ol></li><li class="chapter-item expanded "><a href="layer/trd/token_bucket.html"><strong aria-hidden="true">11.</strong> A token bucket like algorithm for auto task yielding</a></li><li class="chapter-item expanded affix "><li class="part-title">Fourth layer - Reactor and Waker handling</li><li class="chapter-item expanded "><a href="layer/fth/reactor.html"><strong aria-hidden="true">12.</strong> System IO Event Harvester - Reactor</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer/fth/io_registration.html"><strong aria-hidden="true">12.1.</strong> IO event registeration</a></li><li class="chapter-item expanded "><a href="layer/fth/event_handling.html"><strong aria-hidden="true">12.2.</strong> Event handling</a></li><li class="chapter-item expanded "><a href="layer/fth/event_maintain.html"><strong aria-hidden="true">12.3.</strong> Event maintain for late use</a></li></ol></li><li class="chapter-item expanded "><a href="layer/fth/waker_handling.html"><strong aria-hidden="true">13.</strong> Waker handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer/fth/global_map.html"><strong aria-hidden="true">13.1.</strong> Global slab for wakers</a></li><li class="chapter-item expanded "><a href="layer/fth/registration.html"><strong aria-hidden="true">13.2.</strong> Waker registration</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Unresolved Problems and Future Works</li><li class="chapter-item expanded "><a href="prob/load_balancing.html"><strong aria-hidden="true">14.</strong> Load Balancing</a></li><li class="chapter-item expanded "><a href="prob/generic_payload.html"><strong aria-hidden="true">15.</strong> Generic Message Payload</a></li><li class="chapter-item expanded "><a href="prob/reactor_abstract.html"><strong aria-hidden="true">16.</strong> Reactor abstraction for different systems</a></li><li class="chapter-item expanded affix "><li class="part-title">References</li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">17.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Design and Implementation Detail of my-async</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is about the design and the implementation of <code>my-async</code>, a Rust async IO runtime.
Why creating a new runtime instead of using <code>tokio</code>? The problem of <code>tokio</code> is that its codebase is
huge and hard to trace down, a least for me.</p>
<p>When I was trying to understand <code>tokio</code>'s approach to async,
there are more than 35000+ lines of code, it's just too much for a CS student like me.
So I decided to work on a new runtime with a clear documentation
over the design and implementation as my graduate project.</p>
<p><code>my-async</code> has the following goals:</p>
<ul>
<li>A convenient interface to wrap over <code>AsFd</code> types.</li>
<li>A <code>Scheduler</code> trait that makes applying new scheduling strategy easy.</li>
<li>A relatively short code that is easy to read.</li>
<li>Having a decent performance compare to <code>tokio</code>.</li>
<li>Clear documentation that can express its design and implementation.</li>
</ul>
<p>Without a doubt, let's get started.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-in-rust"><a class="header" href="#async-in-rust">Async in Rust</a></h1>
<p>Async in Rust is simple and complex at the same time. If you're the user, you can simply do
the following stuff as an async 101:</p>
<pre><code class="language-rust">#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    println!(&quot;Hello async!&quot;);
    let result = async_io_fn_one().await?;
    println(&quot;Get IO result: {}&quot;, result);
    Ok(())
}
</code></pre>
<p>Just that simple.</p>
<p>On the other hand, if you want to dig inside, thing can get quite tricky.</p>
<p>Async in Rust is kind of different from other languages: it doesn't have a standard runtime.
The decision is made by the core language team to:</p>
<ol>
<li>Maintain fexibility over implementations that is suitable to different scenarios</li>
<li>Keep the size of the standard library small.</li>
</ol>
<p>The result of the decision is the <code>Future</code> trait. Anything that implements <code>Future</code> can
use the <code>.await</code> keyword to execute it asynchronously. The compiler can also implement
<code>Future</code> for normal function by adding <code>async</code> before the <code>fn</code> keyword.</p>
<p>The approach however, cause a problem: by the design of the <code>Future</code> trait, it is lazy.
<code>Future</code> won't make any progress to the underlying code until someone use <code>poll()</code> method
to poll it. In other words, <code>Future</code> needs to be polled by some mechanism to work.
There are multiple ways to poll a <code>Future</code> object, most commonly by an executor.</p>
<p>The executor needs to be capable to dispatch, manage, and execute <code>Future</code>. The implementation
of an executor can look very different, depending on the context, resources, and platform.
Generally an executor can be divided to a few parts and will later be discussed in the next part.</p>
<p>There are numbers of executor implementations in exist, such as <code>tokio</code>, <code>async-std</code>, <code>smol</code>, etc.
The problem is that they are not compactible, since executor need to store numerous of states to help
executing the <code>Future</code> objects. The problem is still unsolved until now and hopefully can be solved one day.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-of-an-executors-architechture"><a class="header" href="#overview-of-an-executors-architechture">Overview of an executor's architechture</a></h1>
<p>The diagram of the executor's architechture:
<img src="https://i2.lensdump.com/i/RR65QP.png" alt="Executor Layer" /></p>
<p>By the above diagram, we can divide the executor into 4 layers:</p>
<h2 id="first-layer---future-and-iowrapper"><a class="header" href="#first-layer---future-and-iowrapper">First Layer - Future and IoWrapper</a></h2>
<p>The job of this layer is provide user interaction with the executor in a convenient way.
A global spawner is provided to send command to the executor to spawn an async function or to shutdown the executor.
The spawned function will return a join handle to join and retrieve the return value of that function.</p>
<p><code>IoWrapper</code> is provided for convenient <code>AsFd</code> type wrapping. It also provides <code>ref_io</code> and <code>mut_io</code> for those
IO actions that is not predefined to run as async.</p>
<h2 id="second-layer---executor"><a class="header" href="#second-layer---executor">Second layer - Executor</a></h2>
<p>This is the surface of the executor. The main job of this layer is to handle message from the spawner and command
the underlying scheduler and reactor by corresponding message.</p>
<p>The executor itself will also set up the global spawner, scheduler with all the worker threads, and the reactor thread
on init for the runtime to work. After the executor is initialized, the user is required to <code>block_on</code> a single main
async function to fire up the runtime.</p>
<h2 id="third-layer---scheduler"><a class="header" href="#third-layer---scheduler">Third layer - Scheduler</a></h2>
<p>This layer will adapt the defined scheduling strategy to schedule async tasks to the workers.
The provided <code>Scheduler</code> trait is an abstract layer that defines a scheduler's basic behavior for executor to use.
This is crutial for new scheduling strategy to be able to plug into this runtime easily.</p>
<p>Currently, <code>RoundRobinScheduler</code>, <code>WorkStealingScheduler</code>, and <code>HybridScheduler</code> is implemented by default.</p>
<h2 id="fourth-layer---reactor-and-waker-handling"><a class="header" href="#fourth-layer---reactor-and-waker-handling">Fourth layer - Reactor and Waker Handling</a></h2>
<p>This layer will communicate with the system and harvest all IO events repoted. Once the IO events are harvested,
the reactor will:</p>
<ol>
<li>If there are wakers registed related to a event, wake it up.</li>
<li>If not, store it to a table for later usage.</li>
</ol>
<p>Since the underlying call is handled by <code>mio</code> that is edge-triggered, we need to check the stored events
with currently registered wakers to make sure every event is consumed.</p>
<p>The datails of the layer will be discussed later in the following chapters, but first, I will give an implementation
of a single-threaded executor to help you understand the main idea of an executor, then we'll move on to the multi-threaded version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-minimal-single-threded-future-evaluator"><a class="header" href="#a-minimal-single-threded-future-evaluator">A minimal single-threded Future evaluator</a></h1>
<p>This section will give an simple single-threaded executor implementation
for you to understand the whole picture of the following chapters, as</p>
<ol>
<li>It doesnt't require a scheduler and any synchronisation.</li>
<li>The reacter is a relatively small factor to express the idea, we'll talk about it later.</li>
</ol>
<p>If you want to see the reactor's part first, see <a href="pre/../layer/fth/reactor.html">System IO Event Harvester - Reactor</a>
and the following subsections.</p>
<p>Now, let's get started from <code>Future</code> handling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-handling"><a class="header" href="#future-handling">Future handling</a></h1>
<p>Since the compiler will generate any <code>async fn</code> functions as <code>Future</code> objects,
the generic type will be a hurdle to program, allocating these <code>Future</code> objects
as boxed trait objects is more sensable and easier to program.</p>
<p>First we define a <code>BoxedLocal&lt;T&gt;</code> type alias and <code>BoxedFuture</code> type:</p>
<pre><code class="language-rust  noplaypen">type BoxedLocal&lt;T&gt; = Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + 'static&gt;&gt;;

struct BoxedFuture {
    future: RefCell&lt;Option&lt;BoxedLocal&lt;io::Result&lt;()&gt;&gt;&gt;&gt;,
}
</code></pre>
<p>Here we use <code>RefCell</code> for internal mutability and we assumed that all
enclosed should return <code>std::io::Result&lt;()&gt;</code> as <code>Future</code> requires to mutate it self
by its trait definition and most of the tasks are IO bounded to be used under async environments.</p>
<p>To handle the underlying <code>async fn</code>, we define the <code>run</code> function as the following:</p>
<pre><code class="language-rust">impl BoxedFuture {
    fn run(&amp;self, index: &amp;FutureIndex, tx: Sender&lt;FutureIndex&gt;) -&gt; bool {
        let mut guard = self.future.borrow_mut();
        // run *ONCE*
        if let Some(fut) = guard.as_mut() {
            let new_index = FutureIndex {
                key: index.key,
            };
            // Create a waker that sends back the future to the process queue
            // once it's woke by that reactor.
            let waker = waker_fn(move || {
                tx.send(new_index).expect(&quot;Too many message queued!&quot;);
            });
            // Create a Context from the waker we just created.
            let cx = &amp;mut Context::from_waker(&amp;waker);
            // Poll the underlying future with cx
            match fut.as_mut().poll(cx) {
                Poll::Ready(r) =&gt; {
                    if let Err(e) = r {
                        // log error to logging facility
                        log::error!(&quot;Error occurred when executing future: {}&quot;, e);
                    }
                    true // Return value ready
                }
                Poll::Pending =&gt; false, // Pending
            }
        } else {
            true // Finished already
        }
    }
}
</code></pre>
<p>The process goes by:</p>
<ol>
<li>Check if it's done already for handling spurious call.</li>
<li>Create a waker that sends the index of itself back to process queue.</li>
<li>Create a <code>Context</code> for future polling using the waker we've just created.</li>
<li>Poll the future and match the result.</li>
</ol>
<p>Next, we'll talk about the global storage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-storages"><a class="header" href="#global-storages">Global Storages</a></h1>
<p>By the design from me, every future should store in a global allocation pool for
allocation reuse and easy management. The details will be discussed in the
<a href="pre/../layer/fst/pool.html">Global Reusable Object Pool for fragment controll and Future managment</a>
part.</p>
<p>We first define <code>FUTURE_POOL</code> and <code>SPAWNER</code> as thread local objects as Rust assumes
you are under multi-threaded environment without specific instruction. This will
cause some bounds for global variables to guarentee memory safety.</p>
<pre><code class="language-rust">thread_local! {
    static SPAWNER: RefCell&lt;Option&lt;Spawner&gt;&gt; = RefCell::new(None);
    static FUTURE_POOL: Pool&lt;BoxedFuture&gt; = Pool::new();
}
</code></pre>
<p>Since <code>Pool</code> is already lock-free, we don't need to use <code>RefCell</code> to encapsulate it.
The <code>SPAWNER</code> is used as an message sender and will be discuss in the next section.</p>
<p>We also need to define a <code>FutureIndex</code> that contains the key returned by the <code>Pool</code> and other
payloads(Though there are no other payloads in this case):</p>
<pre><code class="language-rust">#[derive(Clone, Copy, Eq)]
struct FutureIndex {
    key: usize,
}

impl PartialEq for FutureIndex {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.key == other.key
    }
}

impl Hash for FutureIndex {
    fn hash&lt;H: std::hash::Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.key.hash(state);
    }
}
</code></pre>
<p>and implement <code>Clear</code> for the <code>BoxedFuture</code> for the allocation reserve part:</p>
<pre><code class="language-rust">impl Clear for BoxedFuture {
    fn clear(&amp;mut self) {
        self.future.borrow_mut().clear();
    }
}
</code></pre>
<p>Next, we'll move on to the message passing part.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-passing"><a class="header" href="#message-passing">Message Passing</a></h1>
<p>The <code>SPAWNER</code> we defined in the last part is used as a global message sender,
the underlying type is defined as:</p>
<pre><code class="language-rust">struct Spawner {
    tx: Sender&lt;Message&gt;,
}

enum Message {
    Run(FutureIndex),
    Close,
}
</code></pre>
<p>while the receiver half is held by tthe executor.
The are two messages: <code>Run</code> and <code>Close</code>:</p>
<ul>
<li><code>Run</code> is used to put the spawned future into the process queue.</li>
<li><code>Close</code> is used to signal the executor to shutdown.</li>
</ul>
<p>With the messages defined, we need to implement the corresponding functions:</p>
<pre><code class="language-rust">impl Spawner {
    fn spawn&lt;F&gt;(&amp;self, future: F)
    where
        F: Future&lt;Output = io::Result&lt;()&gt;&gt; + 'static,
    {
        // Alloc future inside the pool and retrieve its key to the entry.
        let key = FUTURE_POOL.with(|p| {
            p.create_with(|seat| {
                seat.future.borrow_mut().replace(Box::pin(future));
            })
            .unwrap()
        });
        // Send run command to the executor.
        self.tx
            .send(Message::Run(FutureIndex {
                key,
            }))
            .expect(&quot;too many task queued&quot;);
    }
    fn shutdown(&amp;self) {
        // Send shutdown command to the executor.
        self.tx.send(Message::Close).expect(&quot;too many task queued&quot;);
    }
}

// Corresponding public function for global spawner access.

pub fn spawn&lt;F&gt;(fut: F)
where
    F: Future&lt;Output = io::Result&lt;()&gt;&gt; + 'static,
{
    SPAWNER.with(|s| {
        if let Some(spawner) = s.borrow().as_ref() {
            spawner.spawn(fut);
        }
    })
}

pub fn shutdown() {
    SPAWNER.with(|s| {
        if let Some(spawner) = s.borrow().as_ref() {
            spawner.shutdown();
        }
    })
}
</code></pre>
<p>Note that the join handle is not implemented in this single-threaded executor for simplicity.
For the join handle implementation, please look <a href="pre/../layer/snd/join_handle.html">Join Handle for Future</a>.</p>
<p>Finally, we come to the main loop that handles the message.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executor-main-loop"><a class="header" href="#executor-main-loop">Executor Main Loop</a></h1>
<p>Inside the main loop, there are a few stages:</p>
<ol>
<li>Pop and make a certain of progress of all futures in the waiting queue.</li>
<li>Try to receive to receive as much as futures that is waken up by the reactor.</li>
<li>Try to receive any message from the spawner.</li>
<li>Finally, wait for reactor to harvest events.</li>
</ol>
<h2 id="stage-1"><a class="header" href="#stage-1">Stage 1</a></h2>
<pre><code class="language-rust">let mut reactor = reactor::Reactor::default();
reactor.setup_registry();
'outer: loop {
    if let Some(index) = self.queue.pop_back() {
        FUTURE_POOL.with(|p| {
            if let Some(boxed) = p.get(index.key) {
                let finished = boxed.run(&amp;index, self.task_tx.clone());
                if finished &amp;&amp; !p.clear(index.key) {
                    log::error!(
                        &quot;Failed to remove completed future with index = {} from pool.&quot;,
                        index.key
                    );
                }
            } else {
                log::error!(&quot;Future with index = {} is not in pool.&quot;, index.key);
            }
        });
    } else {
      // Other stages
    }
}
</code></pre>
<p>Here we first setup the reactor for later use, and start popping <code>FutureIndex</code>s from
waiting queue. The error handling here is simply log the errors to the logging facility
for maintaining a short code. The process can be addressed as:</p>
<ol>
<li>Retrieve the <code>BoxedFuture</code> by the key of <code>FutureIndex</code>.</li>
<li>Use <code>BoxedFuture::run()</code> to make progress with the return value indicating id it's finished.</li>
<li>If it's finished, delete it from the global storage.</li>
</ol>
<h2 id="stage-2"><a class="header" href="#stage-2">Stage 2</a></h2>
<pre><code class="language-rust">'outer: loop {
    if let Some(index) = self.queue.pop_back() {
        // Stage 1
    } else {
        let mut wakeup_count = 0;
        loop {
            match self.task_rx.try_recv() {
                Ok(index) =&gt; {
                    wakeup_count += 1;
                    self.queue.push_front(index);
                }
                Err(TryRecvError::Empty) =&gt; break,
                Err(TryRecvError::Disconnected) =&gt; break 'outer,
            }
        }
        if wakeup_count &gt; 0 {
            continue;
        }
        // Other stages
    }
}
</code></pre>
<p>Here we use a counter to record the number of woke up futures. If there is any,
process those future first. The receive is non-blocking, so two possible error
will need to be handle:</p>
<ol>
<li><code>TryRecvError::Empty</code>: The channel is empty, stop trying to receive.</li>
<li><code>TryRecvError::Disconnected</code>: All the producer are disconnected, which means all futures are done, exit main loop directly.</li>
</ol>
<h2 id="stage-3-and-stage-4"><a class="header" href="#stage-3-and-stage-4">Stage 3 and Stage 4</a></h2>
<pre><code class="language-rust">'outer: loop {
    if let Some(index) = self.queue.pop_back() {
        // Stage 1
    } else {
        // Stage 2
        match self.rx.try_recv() {
            Ok(Message::Run(index)) =&gt; {
                self.queue.push_front(index);
            }
            Err(TryRecvError::Empty) =&gt; {
                if let Err(e) = reactor.wait(Some(Duration::from_millis(50))) {
                    log::error!(&quot;reactor wait error: {}, exit&quot;, e);
                    break;
                }
            }
            Ok(Message::Close) | Err(TryRecvError::Disconnected) =&gt; break,
        }
    }
}
</code></pre>
<p>These are the last stage in the main loop. Here the runtime will wait for any schedule messages
send by the global spawner, whether to run a new future or shutdown the runtime.
If there are no messages from the global spwaner, we start to wait for reactor to wake up some futures.</p>
<p>Note that we need to check messages from global spawner at the same time, so we can't use indefinite
waiting on reactor. A time period need to be chosen to block the loop for a decent small amount of time
without spuriously wake up the main thread too frequently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-code"><a class="header" href="#final-code">Final Code</a></h1>
<p>The final code is shown as below:</p>
<pre><code class="language-rust">use super::reactor;

use std::{
    cell::RefCell,
    collections::VecDeque,
    future::Future,
    hash::Hash,
    io,
    pin::Pin,
    rc::Rc,
    task::{Context, Poll},
    time::Duration,
};

use flume::{Receiver, Sender, TryRecvError};
use sharded_slab::{Clear, Pool};
use waker_fn::waker_fn;

thread_local! {
    static SPAWNER: RefCell&lt;Option&lt;Spawner&gt;&gt; = RefCell::new(None);
    static FUTURE_POOL: Pool&lt;BoxedFuture&gt; = Pool::new();
}

type BoxedLocal&lt;T&gt; = Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + 'static&gt;&gt;;

#[derive(Clone, Copy, Eq)]
struct FutureIndex {
    key: usize,
}

impl PartialEq for FutureIndex {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.key == other.key
    }
}

impl Hash for FutureIndex {
    fn hash&lt;H: std::hash::Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.key.hash(state);
    }
}

struct BoxedFuture {
    future: RefCell&lt;Option&lt;BoxedLocal&lt;io::Result&lt;()&gt;&gt;&gt;&gt;,
}

impl Default for BoxedFuture {
    fn default() -&gt; Self {
        BoxedFuture {
            future: RefCell::new(None),
        }
    }
}

impl Clear for BoxedFuture {
    fn clear(&amp;mut self) {
        self.future.borrow_mut().clear();
    }
}

impl BoxedFuture {
    fn run(&amp;self, index: &amp;FutureIndex, tx: Sender&lt;FutureIndex&gt;) -&gt; bool {
        let mut guard = self.future.borrow_mut();
        // run *ONCE*
        if let Some(fut) = guard.as_mut() {
            let new_index = FutureIndex {
                key: index.key,
            };
            let waker = waker_fn(move || {
                tx.send(new_index).expect(&quot;Too many message queued!&quot;);
            });
            let cx = &amp;mut Context::from_waker(&amp;waker);
            match fut.as_mut().poll(cx) {
                Poll::Ready(r) =&gt; {
                    if let Err(e) = r {
                        log::error!(&quot;Error occurred when executing future: {}&quot;, e);
                    }
                    true
                }
                Poll::Pending =&gt; false,
            }
        } else {
            true
        }
    }
}

enum Message {
    Run(FutureIndex),
    Close,
}

pub struct Executor {
    task_tx: Sender&lt;FutureIndex&gt;,
    task_rx: Receiver&lt;FutureIndex&gt;,
    queue: VecDeque&lt;FutureIndex&gt;,
    rx: Receiver&lt;Message&gt;,
}

struct Spawner {
    tx: Sender&lt;Message&gt;,
}

impl Executor {
    pub fn new() -&gt; Self {
        let (tx, rx) = flume::unbounded();
        let (task_tx, task_rx) = flume::unbounded();
        let spawner = Spawner { tx };
        SPAWNER.with(|s| s.borrow_mut().replace(spawner));
        Self {
            task_tx,
            task_rx,
            queue: VecDeque::with_capacity(1024),
            rx,
        }
    }

    fn run(&amp;mut self) {
        let mut reactor = reactor::Reactor::default();
        reactor.setup_registry();
        'outer: loop {
            if let Some(index) = self.queue.pop_back() {
                FUTURE_POOL.with(|p| {
                    if let Some(boxed) = p.get(index.key) {
                        let finished = boxed.run(&amp;index, self.task_tx.clone());
                        if finished &amp;&amp; !p.clear(index.key) {
                            log::error!(
                                &quot;Failed to remove completed future with index = {} from pool.&quot;,
                                index.key
                            );
                        }
                    } else {
                        log::error!(&quot;Future with index = {} is not in pool.&quot;, index.key);
                    }
                });
            } else {
                let mut wakeup_count = 0;
                loop {
                    match self.task_rx.try_recv() {
                        Ok(index) =&gt; {
                            wakeup_count += 1;
                            self.queue.push_front(index);
                        }
                        Err(TryRecvError::Empty) =&gt; break,
                        Err(TryRecvError::Disconnected) =&gt; break 'outer,
                    }
                }
                if wakeup_count &gt; 0 {
                    continue;
                }
                match self.rx.try_recv() {
                    Ok(Message::Run(index)) =&gt; {
                        self.queue.push_front(index);
                    }
                    Err(TryRecvError::Empty) =&gt; {
                        if let Err(e) = reactor.wait(Some(Duration::from_millis(50))) {
                            log::error!(&quot;reactor wait error: {}, exit&quot;, e);
                            break;
                        }
                    }
                    Ok(Message::Close) | Err(TryRecvError::Disconnected) =&gt; break,
                }
            }
        }
    }
    pub fn block_on&lt;F&gt;(mut self, future: F) -&gt; F::Output
    where
        F: Future + 'static,
    {
        let result_arc: Rc&lt;RefCell&lt;Option&lt;F::Output&gt;&gt;&gt; = Rc::new(RefCell::new(None));
        let clone = Rc::clone(&amp;result_arc);
        spawn(async move {
            let result = future.await;
            clone.borrow_mut().replace(result);
            log::debug!(&quot;Blocked future finished.&quot;);
            shutdown();
            Ok(())
        });
        log::info!(&quot;Start blocking...&quot;);
        self.run();
        log::debug!(&quot;Waiting result...&quot;);
        let mut guard = result_arc.borrow_mut();
        let result = guard.take();
        assert!(
            result.is_some(),
            &quot;The blocked future should produce a return value before the execution ends.&quot;
        );
        result.unwrap()
    }
}

impl Drop for Executor {
    fn drop(&amp;mut self) {
        SPAWNER.with(|s| {
            if let Some(spawner) = s.borrow().as_ref() {
                spawner
                    .tx
                    .send(Message::Close)
                    .expect(&quot;Message queue is full.&quot;);
            }
        });
    }
}

impl Default for Executor {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl Spawner {
    fn spawn&lt;F&gt;(&amp;self, future: F)
    where
        F: Future&lt;Output = io::Result&lt;()&gt;&gt; + 'static,
    {
        let key = FUTURE_POOL.with(|p| {
            p.create_with(|seat| {
                seat.future.borrow_mut().replace(Box::pin(future));
            })
            .unwrap()
        });
        self.tx
            .send(Message::Run(FutureIndex { key }))
            .expect(&quot;too many task queued&quot;);
    }
    fn shutdown(&amp;self) {
        self.tx.send(Message::Close).expect(&quot;too many task queued&quot;);
    }
}

pub fn spawn&lt;F&gt;(fut: F)
where
    F: Future&lt;Output = io::Result&lt;()&gt;&gt; + 'static,
{
    SPAWNER.with(|s| {
        if let Some(spawner) = s.borrow().as_ref() {
            spawner.spawn(fut);
        }
    })
}

pub fn shutdown() {
    SPAWNER.with(|s| {
        if let Some(spawner) = s.borrow().as_ref() {
            spawner.shutdown();
        }
    })
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bone-of-async---future-trait"><a class="header" href="#bone-of-async---future-trait">Bone of async - Future trait</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-in-depth"><a class="header" href="#future-in-depth">Future in depth</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-desugar---a-finite-state-machine"><a class="header" href="#future-desugar---a-finite-state-machine">Future desugar - a Finite State Machine</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-trait-mechanism"><a class="header" href="#future-trait-mechanism">Future trait mechanism</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-challenge-of-implementing-an-executor"><a class="header" href="#the-challenge-of-implementing-an-executor">The challenge of implementing an executor</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-future-handling"><a class="header" href="#generic-future-handling">Generic Future handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-heap-allocated-future-object"><a class="header" href="#general-heap-allocated-future-object">General heap-allocated Future object</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-reusable-object-pool-for-fragment-controll-and-future-managment"><a class="header" href="#global-reusable-object-pool-for-fragment-controll-and-future-managment">Global Reusable Object Pool for fragment controll and Future managment</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-adapter-for-general-file-descriptor---iowrapper"><a class="header" href="#io-adapter-for-general-file-descriptor---iowrapper">IO Adapter for general file descriptor - IoWrapper</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-io-handling"><a class="header" href="#general-io-handling">General IO handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iowrapper-design"><a class="header" href="#iowrapper-design">IoWrapper design</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heart-of-a-runtime---executor"><a class="header" href="#heart-of-a-runtime---executor">Heart of a runtime - Executor</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-commands-of-a-runtime"><a class="header" href="#general-commands-of-a-runtime">General commands of a runtime</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-of-executor---an-abstraction-to-scheduler-and-reactor"><a class="header" href="#design-of-executor---an-abstraction-to-scheduler-and-reactor">Design of Executor - an abstraction to scheduler and reactor</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="passing-messages"><a class="header" href="#passing-messages">Passing messages</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawner---message-sender"><a class="header" href="#spawner---message-sender">Spawner - message sender</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-payload"><a class="header" href="#message-payload">Message payload</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join-handle-for-future"><a class="header" href="#join-handle-for-future">Join Handle for Future</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multithread-mania---scheduler"><a class="header" href="#multithread-mania---scheduler">Multithread mania - Scheduler</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scheduler-trait-design"><a class="header" href="#scheduler-trait-design">Scheduler trait design</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-worker-structure-and-logic"><a class="header" href="#general-worker-structure-and-logic">General Worker structure and logic</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threading-method"><a class="header" href="#threading-method">Threading Method</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="round-robin"><a class="header" href="#round-robin">Round Robin</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="work-stealing"><a class="header" href="#work-stealing">Work Stealing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hybrid-queue-for-prioritized-work-stealing"><a class="header" href="#hybrid-queue-for-prioritized-work-stealing">Hybrid Queue for Prioritized Work Stealing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-token-bucket-like-algorithm-for-auto-task-yielding"><a class="header" href="#a-token-bucket-like-algorithm-for-auto-task-yielding">A token bucket like algorithm for auto task yielding</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-io-event-harvester---reactor"><a class="header" href="#system-io-event-harvester---reactor">System IO Event Harvester - Reactor</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-event-registeration"><a class="header" href="#io-event-registeration">IO event registeration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handling"><a class="header" href="#event-handling">Event handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-maintain-for-late-use"><a class="header" href="#event-maintain-for-late-use">Event maintain for late use</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waker-handling"><a class="header" href="#waker-handling">Waker handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-slab-for-wakers"><a class="header" href="#global-slab-for-wakers">Global slab for wakers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="waker-registration"><a class="header" href="#waker-registration">Waker registration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="load-balancing"><a class="header" href="#load-balancing">Load Balancing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-message-payload"><a class="header" href="#generic-message-payload">Generic Message Payload</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactor-abstraction-for-different-systems"><a class="header" href="#reactor-abstraction-for-different-systems">Reactor abstraction for different systems</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
